const { rejects } = require('assert');
const fs = require('fs')
const path = require("path");
const util = require("util")
let dirN = __dirname
const directoryName = dirN.replace(/(\s+)/g, '\\$1');
const engineV2headers = JSON.parse(fs.readFileSync(path.join(__dirname,`/headers.json`))).headersList


const getDLLPath = `${directoryName}/parsing/PEDLLParser`
// const getMLPath = "./goComp/PEDLLParser/dll"

const getEntropyPath = path.join(directoryName, `/parsing/EntropyUtil`)
const getFileSize = path.join(directoryName, `/parsing/getFileSize`)
const getHeaderInfo = path.join(directoryName, `/parsing/headerUtil`)
const getFileFunctions = `python ` + path.join(directoryName, `/parsing/dllFunctionCallParser/analysePE.py`)
const DLL_DATA = path.join(__dirname, `/DLL_DATA.json`)
// const DLL_DATA = dllRaw.split(/\ /).join('\ ')
const FUNCTION_DATA = path.join(__dirname, `/FUNCTION_DATA.json`)
// const FUNCTION_DATA = FUNCTION_RAW.split(/\ /).join('\ ')
// const PYCALL = `python3 ` + path.join(directoryName, `/ML/runBayesNet.py`) + ` ` + path.join(directoryName, `/ML/dat.csv`) 

const createCsvWriter = require('csv-writer').createObjectCsvWriter;
// const exec = require('child_process').exec
const execSync = require('child_process').execSync

let dataObj = {}

const main = (filepathIN) => {
    return new Promise((resolve, reject) => {


        let allData = []

        let filePath = ''



        filePath = filepathIN.replace(/(\s+)/g, '\\$1')


        dataObj['file'] = filePath
        dataObj['IsMalicous'] = '?'
        console.log(filePath)
        try {
            let data = execSync(`${getDLLPath} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
            let pdata = data.split(/\r?\n/)
            pdata = pdata.filter(item => item);
            dataObj['DLL'] = pdata
            dataObj['Number of DLLS'] = pdata.length
        }
        catch (e) {
            dataObj['DLL'] = '?'
            dataObj['Number of DLLS'] = 0

        }

        //get entropy
        try {
            let data = execSync(`${getEntropyPath} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
            let ent = parseFloat(data.split(/\r?\n/))
            if (!isNaN(ent)) {

                dataObj['Entropy'] = ent
            }
            else {
                dataObj['Entropy'] = '?'

            }

        }
        catch (e) {
            console.log(`can't open: ${e}`)
            dataObj['Entropy'] = '?'

        }

        //get file size
        try {
            let data = execSync(`${getFileSize} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
            dataObj['File Size'] = parseInt(data.split(/\r?\n/))

        }
        catch (e) {
            console.log(`can't open: ${e}`)
            dataObj['File Size'] = '?'

        }

        //get header data 
        try {
            let data = execSync(`${getHeaderInfo} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
            data = data.replace(/\r?\n|\r/g, "");
            let pdata = data.split(' ')

            dataObj['DLL File'] = pdata[0]
            dataObj['SYS File'] = pdata[1]
            dataObj['base'] = pdata[2]
            dataObj['File Type 1'] = pdata[3]
            dataObj['File Type 2'] = pdata[4]
            dataObj['First DOS Header'] = pdata[5]
            dataObj['Second DOS Header'] = pdata[6]
            dataObj['Magic'] = pdata[7]

        }
        catch (e) {
            // console.log(e)
            dataObj['DLL File'] = 'false'
            dataObj['SYS File'] = 'false'
            dataObj['base'] = '?'
            dataObj['File Type 1'] = '?'
            dataObj['File Type 2'] = '?'
            dataObj['First DOS Header'] = '?'
            dataObj['Second DOS Header'] = '?'
            dataObj['Magic'] = '?'
        }

        //get imported functions
        try {
            let data = execSync(`${getFileFunctions} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
            let lineData = data.split('\n')

            let allFuncs = []

            for (let i = 0; i < lineData.length; i++) {
                if (!lineData[i].includes(".dll")) {
                    lineData[i] = lineData[i].replace(/\r?\n|\r/g, "");
                    let func = lineData[i].split(':')
                    if (typeof (func[1]) != 'undefined' && func != '') {
                        allFuncs.push(func[1])
                    }

                }
            }

            allFuncs = allFuncs.filter(item => item);
            dataObj['Number of Functions'] = allFuncs.length
            dataObj['functions'] = allFuncs

        }
        catch (e) {
            dataObj['functions'] = ''

        }

        generateCSV().then((result) => {
            console.log(result)
            resolve(result)
        })
    })

}

const getFreq = (list, matchString) => {
    let count = 0
    list.forEach((dll) => {
        if (matchString == dll) {
            count++
        }
    })

    return count
}

/*
Generates the CSV and tests if its malware
*/
const generateCSV = () => {
    return new Promise((resolve, reject) => {


        let DLLData = JSON.parse(fs.readFileSync(DLL_DATA))
        let FuncData = JSON.parse(fs.readFileSync(FUNCTION_DATA))
        // console.log(DLLData)
        // console.log(FuncData)

        let file = dataObj
        // console.log(file)
        for (let i = 0; i < DLLData.DLL_LIST.length; i++) {
            dataObj[DLLData.DLL_LIST[i].replace(' ','')] = 0
        }
    
        for (let b = 0; b < dataObj.DLL.length; b++) {
            if (DLLData.DLL_LIST.includes(file.DLL[b])) {
                dataObj[dataObj.DLL[b].replace(' ','')] = 1
            }
        }
    
        for (let i = 0; i < FuncData.FUNC_LIST.length; i++) {
            dataObj[FuncData.FUNC_LIST[i].replace(' ','')] = 0
        }
    
        for (let b = 0; b < dataObj.functions.length; b++) {
            if (FuncData.FUNC_LIST.includes(dataObj.functions[b])) {
                dataObj[file.functions[b].replace(' ','')] = 1
            }
        }

        // }


        //run all the files through go engine & store output 
        let headers = []
        let cleanedDataObj = {}
        // console.log(dataObj)
        engineV2headers.forEach((header) => {
            headers.push({
                id:header,
                title:header
            })
            // console.log(header)
            // console.log(dataObj[header])
           cleanedDataObj[header] = dataObj[header]
        })
    

        const csvWriter = createCsvWriter({
            path: path.join(__dirname, "/ML/dat.csv"),
            header: headers

        });

        csvWriter.writeRecords([cleanedDataObj]).then(() => {

            console.log('The CSV file was written successfully, time to evaluate the file')
            try {

                let cmd = path.join(__dirname, `/ML/runBayesNet.py`)
                let target = path.join(__dirname, `/ML/dat.csv`)
                let PYCALL = `python3 ` + cmd.trim().replaceAll(' ', '\\ ') + ` ` + target.trim().replaceAll(' ', '\\ ') + ` ` + directoryName;
                // console.log(PYCALL)


                // let cPYCALL = PYCALL.replace(/(\s+)/g, '\\$1')
                let result = execSync(PYCALL, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
                // console.log(result)

                // console.log('Seeing if it breaks here')

                if (result.includes('MALWARE')) {
                    console.log('Sending M signal')
                    resolve('Malware')
                }
                else {
                    console.log('Sending C signal')
                    resolve('Clean')
                }

            }
            catch (e) {
                console.log(e)
                reject(`Error ${e}`)
            }

        }).catch((e) => {
            console.log(e)
            reject(`Error ${e}`)
        });


    })

}

// const MainAsync  = util.promisify(main)
module.exports.main = main;


