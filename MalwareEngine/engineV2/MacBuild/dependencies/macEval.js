const fs = require('fs')
const path = require("path");

let dirN = __dirname
const directoryName = dirN.replace(/(\s+)/g, '\\$1');
// PYCALL.replace(/(\s+)/g, '\\$1')
// const PE = require('portable-executable') Dont really need this 

const getDLLPath = `${directoryName}/parsing/PEDLLParser`
// const getMLPath = "./goComp/PEDLLParser/dll"

const getEntropyPath = path.join(directoryName, `/parsing/EntropyUtil`)
const getFileSize = path.join(directoryName, `/parsing/getFileSize`)
const getHeaderInfo = path.join(directoryName, `/parsing/headerUtil`)
const getFileFunctions = `python ` + path.join(directoryName, `/parsing/dllFunctionCallParser/analysePE.py`)
const DLL_DATA = path.join(__dirname, `/DLL_DATA.json`)
// const DLL_DATA = dllRaw.split(/\ /).join('\ ')
const FUNCTION_DATA = path.join(__dirname, `/FUNCTION_DATA.json`)
// const FUNCTION_DATA = FUNCTION_RAW.split(/\ /).join('\ ')
// const PYCALL = `python3 ` + path.join(directoryName, `/ML/runBayesNet.py`) + ` ` + path.join(directoryName, `/ML/dat.csv`) 

const createCsvWriter = require('csv-writer').createObjectCsvWriter;
// const exec = require('child_process').exec
const execSync = require('child_process').execSync
const execFileSync = require('child_process').execFileSync

let dataObj = {}

const main = (filepathIN) => {


    // console.log(directoryName)
    // console.log(getEntropyPath)
    // console.log(getHeaderInfo)
    // console.log(getFileFunctions)


    let allData = []

    let filePath = ''


    // console.log(`Welcome to the Malware Analysis Tool\nV1.0.0`)

    filePath = filepathIN.replace(/(\s+)/g, '\\$1')

    // console.log(filePath)
    // if(!fs.existsSync(filePath)){
    //     console.log('File not found')
    //     return 'Error'
    // }

    
    // console.log(filePath)

    // if (!fs.existsSync(filePath)) {
    //     console.log(`usage ${process.argv[1]} ${process.argv[2]}`)
    //     process.exit()
    // }

    /*
        Getting Features
    */
    // console.log(filePath)


    dataObj['file'] = filePath
    dataObj['Malicous'] = '?'

    try {
        let data = execSync(`${getDLLPath} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
        let pdata = data.split(/\r?\n/)
        pdata = pdata.filter(item => item);
        dataObj['DLL'] = pdata
        dataObj['numDLLS'] = pdata.length
    }
    catch (e) {
        dataObj['DLL'] = '?'
        dataObj['numDLLS'] = 0

    }

    //get entropy
    try {
        let data = execSync(`${getEntropyPath} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
        let ent = parseFloat(data.split(/\r?\n/))
        if (!isNaN(ent)) {

            dataObj['entropy'] = ent
        }
        else {
            dataObj['entropy'] = '?'

        }

    }
    catch (e) {
        console.log(`can't open: ${e}`)
        dataObj['entropy'] = '?'

    }

    //get file size
    try {
        let data = execSync(`${getFileSize} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
        dataObj['fileSize'] = parseInt(data.split(/\r?\n/))

    }
    catch (e) {
        console.log(`can't open: ${e}`)
        dataObj['fileSize'] = '?'

    }

    //get header data 
    try {
        let data = execSync(`${getHeaderInfo} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
        data = data.replace(/\r?\n|\r/g, "");
        let pdata = data.split(' ')

        dataObj['isDLL'] = pdata[0]
        dataObj['isSYS'] = pdata[1]
        dataObj['base'] = pdata[2]
        dataObj['file1'] = pdata[3]
        dataObj['file2'] = pdata[4]
        dataObj['dosHeader[0]'] = pdata[5]
        dataObj['dosHeader[1]'] = pdata[6]
        dataObj['MagicNumber'] = pdata[7]

    }
    catch (e) {
        // console.log(e)
        dataObj['isDLL'] = 'false'
        dataObj['isSYS'] = 'false'
        dataObj['base'] = '?'
        dataObj['file1'] = '?'
        dataObj['file2'] = '?'
        dataObj['dosHeader[0]'] = '?'
        dataObj['dosHeader[1]'] = '?'
        dataObj['MagicNumber'] = '?'
    }

    //get imported functions
    try {
        let data = execSync(`${getFileFunctions} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
        let lineData = data.split('\n')

        let allFuncs = []

        for (let i = 0; i < lineData.length; i++) {
            if (!lineData[i].includes(".dll")) {
                lineData[i] = lineData[i].replace(/\r?\n|\r/g, "");
                let func = lineData[i].split(':')
                if (typeof (func[1]) != 'undefined' && func != '') {
                    allFuncs.push(func[1])
                }

            }
        }

        allFuncs = allFuncs.filter(item => item);
        dataObj['numFuncs'] = allFuncs.length
        dataObj['functions'] = allFuncs

    }
    catch (e) {
        dataObj['functions'] = ''

    }

    generateCSV()


}

const getFreq = (list, matchString) => {
    let count = 0
    list.forEach((dll) => {
        if (matchString == dll) {
            count++
        }
    })

    return count
}

/*
Generates the CSV and tests if its malware
*/
const generateCSV = () => {
    let DLLData = JSON.parse(fs.readFileSync(DLL_DATA))
    let FuncData = JSON.parse(fs.readFileSync(FUNCTION_DATA))
    // console.log(DLLData)
    // console.log(FuncData)

    let file = dataObj
    // console.log(file)
    for (let i = 0; i < DLLData.DLL_LIST.length; i++) {
        file[DLLData.DLL_LIST[i]] = 0
    }

    for (let b = 0; b < file.DLL.length; b++) {
        if (DLLData.DLL_LIST.includes(file.DLL[b])) {
            file[file.DLL[b]] = 1
        }
    }

    for (let i = 0; i < FuncData.FUNC_LIST.length; i++) {
        file[FuncData.FUNC_LIST[i]] = 0
    }

    for (let b = 0; b < file.functions.length; b++) {
        if (FuncData.FUNC_LIST.includes(file.functions[b])) {
            file[file.functions[b]] = 1
        }
    }

    // }


    //run all the files through go engine & store output 
    let header = [
        { id: 'Malicous', title: 'IsMalicous' },
        { id: 'numDLLS', title: 'Number of DLLS' },
        { id: 'entropy', title: 'Entropy' },
        { id: 'fileSize', title: 'File Size' },
        { id: 'isSYS', title: 'SYS File' },
        { id: 'isDLL', title: 'DLL File' },
        { id: 'file1', title: 'File Type 1' },
        { id: 'file2', title: 'File Type 2' },
        { id: 'dosHeader[0]', title: 'First DOS Header' },
        { id: 'dosHeader[1]', title: 'Second DOS Header' },
        { id: 'MagicNumber', title: 'Magic' },
        { id: 'numFuncs', title: 'Number of Functions' },


    ]
    //set the features
    for (let x = 0; x < DLLData.DLL_LIST.length; x++) {
        if (DLLData[DLLData.DLL_LIST[x]] > 1) {
            header.push(
                {
                    id: DLLData.DLL_LIST[x],
                    title: DLLData.DLL_LIST[x]
                }
            )
        }
    }

    for (let x = 0; x < FuncData.FUNC_LIST.length; x++) {
        if (FuncData[FuncData.FUNC_LIST[x]] > 3) {
            header.push(
                {
                    id: FuncData.FUNC_LIST[x],
                    title: FuncData.FUNC_LIST[x]
                }
            )
        }
    }

    const csvWriter = createCsvWriter({
        path: path.join(__dirname, "/ML/dat.csv"),
        header: header

    });

    csvWriter.writeRecords([dataObj]).then(() => {

        console.log('The CSV file was written successfully, time to evaluate the file')
        try {

            let cmd = path.join(__dirname, `/ML/runBayesNet.py`)
            let target = path.join(__dirname, `/ML/dat.csv`)
            let PYCALL = `python3 ` + cmd.trim().replaceAll(' ', '\\ ') + ` ` + target.trim().replaceAll(' ', '\\ ') + ` ` + directoryName;
            // console.log(PYCALL)


            // let cPYCALL = PYCALL.replace(/(\s+)/g, '\\$1')
            let result = execSync(PYCALL, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
            console.log(result)

            // console.log('Seeing if it breaks here')

            if (result.includes('MALWARE')) {
                console.log('Sending M signal')
                return 'Malware'
            }
            else {
                console.log('Sending C signal')
                return 'Clean'
            }

        }
        catch (e) {
            console.log(e)
            return `Error ${e}`
        }

    }).catch((e) => {
        console.log(e)
        return `Error ${e}`
    });


    /*
           repair header file
      */
    //         let headers = `@relation out

    // @attribute IsMalicous {malicous,benign}
    // @attribute 'Number of DLLS' numeric
    // @attribute Entropy numeric
    // @attribute 'File Size' numeric
    // @attribute 'SYS File' {FALSE,TRUE}
    // @attribute 'DLL File' {FALSE,TRUE}
    // @attribute 'File Type 1' numeric
    // @attribute 'File Type 2' numeric
    // @attribute 'First DOS Header' numeric
    // @attribute 'Second DOS Header' numeric
    // @attribute Magic numeric
    // @attribute 'Number of Functions' numeric`
    //         //@attribute KERNEL32.dll numeric
    //         //set the features

    //         for (let x = 0; x < DLLData.DLL_LIST.length; x++) {
    //             if (DLLData[DLLData.DLL_LIST[x]] > 1) {
    //                 // header.push(
    //                 //     {
    //                 //         id: DLLData.DLL_LIST[x],
    //                 //         title: DLLData.DLL_LIST[x]
    //                 //     }
    //                 // )
    //                 let str = `\n@attribute ${DLLData.DLL_LIST[x]}numeric`
    //                 headers = headers.concat(str)

    //             }
    //         }

    //         for (let x = 0; x < FuncData.FUNC_LIST.length; x++) {
    //             if (FuncData[FuncData.FUNC_LIST[x]] > 3) {
    //                 // header.push(
    //                 //     {
    //                 //         id: FuncData.FUNC_LIST[x],
    //                 //         title: FuncData.FUNC_LIST[x]
    //                 //     }
    //                 // )
    //                 let str = `\n@attribute${FuncData.FUNC_LIST[x]} numeric`
    //                 headers = headers.concat(str)
    //             }
    //         }

    //         headers = headers.concat(`\n\n@data`)
    //         console.log(headers)

    //         fs.writeFileSync(`./headers2.txt`, headers)
}

module.exports.main = main;


