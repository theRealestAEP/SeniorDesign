const fs = require('fs')

// const PE = require('portable-executable') Dont really need this 

const getDLLPath = "./goComp/PEDLLParser/dll"
// const getMLPath = "./goComp/PEDLLParser/dll"

const getEntropyPath = "./goComp/EntropyUtil/EntropyUtil"
const getFileSize = "./goComp/getFileSize/getFileSize"
const getHeaderInfo = "./goComp/headerUtil/headerUtil"
const getFileFunctions = "python ./dllFunctionCallParser/analysePE.py"
const engineV2headers = JSON.parse(fs.readFileSync("./headers.json")).headersList


// console.log(engineV2headers.headersList)

const createCsvWriter = require('csv-writer').createObjectCsvWriter;

const execSync = require('child_process').execSync


let allData = []

let filePath = ''
let dataObj = {}

const main = () => {

    // console.log(`Welcome to the Malware Analysis Tool\nV1.0.0`)

    filePath = process.argv[2]
    // console.log(filePath)

    if (!fs.existsSync(filePath)) {
        console.log(`usage ${process.argv[1]} ${process.argv[2]}`)
        process.exit()
    }

    /*
        Getting Features
    */
    console.log(filePath)


    dataObj['file'] = filePath
    dataObj['IsMalicous'] = '?'

    try {
        let data = execSync(`${getDLLPath} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
        let pdata = data.split(/\r?\n/)
        pdata = pdata.filter(item => item);
        dataObj['DLL'] = pdata
        dataObj['Number of DLLS'] = pdata.length
    }
    catch (e) {
        dataObj['DLL'] = '?'
        dataObj['Number of DLLS'] = 0

    }

    //get entropy
    try {
        let data = execSync(`${getEntropyPath} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
        let ent = parseFloat(data.split(/\r?\n/))
        if (!isNaN(ent)) {

            dataObj['Entropy'] = ent
        }
        else {
            dataObj['Entropy'] = '?'

        }

    }
    catch (e) {
        // console.log(`can't open: ${e}`)
        dataObj['Entropy'] = '?'

    }

    //get file size
    try {
        let data = execSync(`${getFileSize} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
        dataObj['File Size'] = parseInt(data.split(/\r?\n/))

    }
    catch (e) {
        // console.log(`can't open: ${e}`)
        dataObj['File Size'] = '?'

    }

    //get header data 
    try {
        let data = execSync(`${getHeaderInfo} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
        data = data.replace(/\r?\n|\r/g, "");
        let pdata = data.split(' ')

        dataObj['DLL File'] = pdata[0]
        dataObj['SYS File'] = pdata[1]
        dataObj['base'] = pdata[2]
        dataObj['File Type 1'] = pdata[3]
        dataObj['File Type 2'] = pdata[4]
        dataObj['First DOS Header'] = pdata[5]
        dataObj['Second DOS Header'] = pdata[6]
        dataObj['Magic'] = pdata[7]

    }
    catch (e) {
        // console.log(e)
        dataObj['DLL File'] = 'false'
        dataObj['SYS File'] = 'false'
        dataObj['base'] = '?'
        dataObj['File Type 1'] = '?'
        dataObj['File Type 2'] = '?'
        dataObj['First DOS Header'] = '?'
        dataObj['Second DOS Header'] = '?'
        dataObj['Magic'] = '?'
    }

    //get imported functions
    try {
        let data = execSync(`${getFileFunctions} ${filePath}`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
        let lineData = data.split('\n')

        let allFuncs = []

        for (let i = 0; i < lineData.length; i++) {
            if (!lineData[i].includes(".dll")) {
                lineData[i] = lineData[i].replace(/\r?\n|\r/g, "");
                let func = lineData[i].split(':')
                if (typeof (func[1]) != 'undefined' && func != '') {
                    allFuncs.push(func[1])
                }

            }
        }

        allFuncs = allFuncs.filter(item => item);
        dataObj['Number of Functions'] = allFuncs.length
        dataObj['functions'] = allFuncs

    }
    catch (e) {
        dataObj['functions'] = ''

    }

    generateCSV()


}

const getFreq = (list, matchString) => {
    let count = 0
    list.forEach((dll) => {
        if (matchString == dll) {
            count++
        }
    })

    return count
}

/*
Generates the CSV and tests if its malware
*/
const generateCSV = () => {
    let DLLData = JSON.parse(fs.readFileSync('./DLL_DATA.json'))
    let FuncData = JSON.parse(fs.readFileSync('./FUNCTION_DATA.json'))
    let file = dataObj
    // console.log(file)
    for (let i = 0; i < DLLData.DLL_LIST.length; i++) {
        dataObj[DLLData.DLL_LIST[i].replace(' ','')] = 0
    }

    for (let b = 0; b < dataObj.DLL.length; b++) {
        if (DLLData.DLL_LIST.includes(file.DLL[b])) {
            dataObj[dataObj.DLL[b].replace(' ','')] = 1
        }
    }

    for (let i = 0; i < FuncData.FUNC_LIST.length; i++) {
        dataObj[FuncData.FUNC_LIST[i].replace(' ','')] = 0
    }

    for (let b = 0; b < dataObj.functions.length; b++) {
        if (FuncData.FUNC_LIST.includes(dataObj.functions[b])) {
            dataObj[file.functions[b].replace(' ','')] = 1
        }
    }

    // }


    //Setting the header File

    let headers = []
    let cleanedDataObj = {}
    // console.log(dataObj)
    engineV2headers.forEach((header) => {
        headers.push({
            id:header,
            title:header
        })
        // console.log(header)
        // console.log(dataObj[header])
       cleanedDataObj[header] = dataObj[header]
    })

    const csvWriter = createCsvWriter({
        path: './dat.csv',
        header: headers

    });

    csvWriter.writeRecords([cleanedDataObj]).then(() => {

        console.log('The CSV file was written successfully, time to evaluate the file')
        try {
            let result = execSync(`python3 ./runBayesNet.py dat.csv`, { encoding: 'utf8', maxBuffer: 50 * 1024 * 1024 })
            console.log(result)
        }
        catch (e) {
            console.log(e)
        }

    }).catch((e) => {
        console.log(e)
    });


    /*
           repair header file
      */
//         let headers = `@relation out

// @attribute IsMalicous {malicous,benign}
// @attribute 'Number of DLLS' numeric
// @attribute Entropy numeric
// @attribute 'File Size' numeric
// @attribute 'SYS File' {FALSE,TRUE}
// @attribute 'DLL File' {FALSE,TRUE}
// @attribute 'File Type 1' numeric
// @attribute 'File Type 2' numeric
// @attribute 'First DOS Header' numeric
// @attribute 'Second DOS Header' numeric
// @attribute Magic numeric
// @attribute 'Number of Functions' numeric`
//         //@attribute KERNEL32.dll numeric
//         //set the features

//         for (let x = 0; x < DLLData.DLL_LIST.length; x++) {
//             if (DLLData[DLLData.DLL_LIST[x]] > 1) {
//                 // header.push(
//                 //     {
//                 //         id: DLLData.DLL_LIST[x],
//                 //         title: DLLData.DLL_LIST[x]
//                 //     }
//                 // )
//                 let str = `\n@attribute ${DLLData.DLL_LIST[x]}numeric`
//                 headers = headers.concat(str)

//             }
//         }

//         for (let x = 0; x < FuncData.FUNC_LIST.length; x++) {
//             if (FuncData[FuncData.FUNC_LIST[x]] > 3) {
//                 // header.push(
//                 //     {
//                 //         id: FuncData.FUNC_LIST[x],
//                 //         title: FuncData.FUNC_LIST[x]
//                 //     }
//                 // )
//                 let str = `\n@attribute${FuncData.FUNC_LIST[x]} numeric`
//                 headers = headers.concat(str)
//             }
//         }

//         headers = headers.concat(`\n\n@data`)
//         console.log(headers)

//         fs.writeFileSync(`./headers2.txt`, headers)
}

main()


